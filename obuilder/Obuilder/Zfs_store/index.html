<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Zfs_store (obuilder.Obuilder.Zfs_store)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">obuilder</a> &#x00BB; <a href="../index.html">Obuilder</a> &#x00BB; Zfs_store</nav><h1>Module <code>Obuilder.Zfs_store</code></h1><p>Store build results as ZFS snapshots.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../S/index.html#module-type-STORE">S.STORE</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-build"><a href="#val-build" class="anchor"></a><code><span class="keyword">val</span> build : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>?&#8288;base:<a href="../S/index.html#type-id">S.id</a></span> <span>&#45;&gt;</span> <span>id:<a href="../S/index.html#type-id">S.id</a></span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'e</span>)</span> Lwt_result.t</span>)</span> <span>&#45;&gt;</span> <span><span>(unit, <span class="type-var">'e</span>)</span> Lwt_result.t</span></code></dt><dd><p><code>build t ~id fn</code> runs <code>fn tmpdir</code> to add a new item to the store under key <code>id</code>. On success, <code>tmpdir</code> is saved as <code>id</code>, which can be used as the <code>base</code> for further builds, until it is expired from the cache. On failure, nothing is recorded and calling <code>build</code> again will make another attempt at building it. The builder will not request concurrent builds for the same <code>id</code> (it will handle that itself). It will also not ask for a build that already exists (i.e. for which <code>result</code> returns a path).</p><dl><dt>parameter base</dt><dd><p>Initialise <code>tmpdir</code> as a clone of <code>base</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-delete"><a href="#val-delete" class="anchor"></a><code><span class="keyword">val</span> delete : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../S/index.html#type-id">S.id</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>delete t id</code> removes <code>id</code> from the store, if present.</p></dd></dl><dl><dt class="spec value" id="val-result"><a href="#val-result" class="anchor"></a><code><span class="keyword">val</span> result : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../S/index.html#type-id">S.id</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>result t id</code> is the path of the build result for <code>id</code>, if present.</p></dd></dl><dl><dt class="spec value" id="val-state_dir"><a href="#val-state_dir" class="anchor"></a><code><span class="keyword">val</span> state_dir : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>state_dir</code> is the path of a directory which can be used to store mutable state related to this store (e.g. an sqlite3 database).</p></dd></dl><dl><dt class="spec value" id="val-cache"><a href="#val-cache" class="anchor"></a><code><span class="keyword">val</span> cache : <span>user:<a href="../../../obuilder-spec/Obuilder_spec/index.html#type-user">Obuilder_spec.user</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(string * <span>(unit <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span>)</span> Lwt.t</span></code></dt><dd><p><code>cache ~user t name</code> creates a writeable copy of the latest snapshot of the cache <code>name</code>. It returns the path of this fresh copy and a function which must be called to free it when done. If the cache <code>name</code> does not exist, it is first created (as an empty directory, and owned by <code>user</code>). When the copy is released, it is snapshotted to become the new latest version of the cache, unless the cache has already been updated since it was snapshotted, in which case this writeable copy is simply discarded.</p></dd></dl><dl><dt class="spec value" id="val-delete_cache"><a href="#val-delete_cache" class="anchor"></a><code><span class="keyword">val</span> delete_cache : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(unit, <span>[&gt; `Busy ]</span>)</span> Lwt_result.t</span></code></dt><dd><p><code>delete_cache t name</code> removes the cache <code>name</code>, if present. If the cache is currently in use, the store may instead return <code>Error `Busy</code>.</p></dd></dl><dl><dt class="spec value" id="val-complete_deletes"><a href="#val-complete_deletes" class="anchor"></a><code><span class="keyword">val</span> complete_deletes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>unit Lwt.t</span></code></dt><dd><p><code>complete_deletes t</code> attempts to wait for previously executed deletes to finish, so that the free space is accurate.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>pool:string</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Lwt.t</span></code></dt><dd><p><code>create ~pool</code> is a new store in zfs pool <code>pool</code>.</p></dd></dl></div></body></html>